/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//import 'foundation-sites/js/foundation.core';
//import 'foundation-sites/js/foundation.util.mediaQuery';

// Animated svg sections
module.exports = function () {
    function AnimatedSheet(svgSelector, options) {
        _classCallCheck(this, AnimatedSheet);

        d3.selection.prototype.moveToFront = function () {
            return this.each(function () {
                this.parentNode.appendChild(this);
            });
        };

        this.svgElement = $(svgSelector);
        //if(this.svgElement) {
        //    this.svg = svgElement;
        //} else {
        if (!this.svgElement.length) {
            console.error('No svg found by selector "' + svgSelector + '"');
            return false;
        }

        this.d3Svg = d3.select(svgSelector).attr('width', options.width ? options.width : '100%');

        var self = this;

        //Foundation.MediaQuery._init();

        // resize viewbox on small displays
        var reformatViewbox = function reformatViewbox() {
            var sheetWidth = 1920;
            var sheetHeight = 1080;
            var positionShiftX = 0;
            var positionShiftY = -(1 / window.innerWidth) * 100 * 100 * 25;
            var viewboxValue = positionShiftX + ' ' + positionShiftY + ' ' + sheetWidth + ' ' + sheetHeight;

            viewboxValue = "0 -150 1920 2000";

            //console.log('reformat', positionShiftY);

            var small = 640;
            var medium = 1024;

            self.d3Svg.attr('height', 2000).attr('viewBox', viewboxValue).attr('preserveAspectRatio', 'xMinYMin meet');

            //console.log(window.innerWidth,  medium);

            // empty when using webpack (https://github.com/zurb/foundation-sites/issues/10363):
            //if(Foundation.MediaQuery.current === 'small') {
            if (window.innerWidth <= small) {
                //console.log('setting sheet to small');
                self.d3Svg.attr('height', 667);
            } else
                //if(Foundation.MediaQuery.current === 'medium') {
                if (window.innerWidth <= medium) {
                    //console.log('setting sheet to medium');
                    self.d3Svg.attr('height', 1024);
                }
        };

        this.scopes = [];

        if (options.defs) {
            options.defs.forEach(function (def, index) {
                if (def.filter) {
                    def.filter(self.d3Svg);
                }
            });
        }

        //this.init = function() {
        options.keyframes.forEach(function (keyframe, scopeIndex) {
            var createScope = keyframe.create(self.d3Svg);
            if (createScope.element) {
                createScope.element.attr('visibility', 'visible');
            } else {
                console.warn('The create function should return the element key, so it can be accessed in the animate/interpolate function via the "createScope" parameter');
            }
            self.scopes[scopeIndex] = createScope;
        });
        reformatViewbox();
        window.addEventListener('resize', reformatViewbox);
        //}();
        this.keyframes = options.keyframes;

        return this.animate();
    }

    _createClass(AnimatedSheet, [{
        key: 'animate',
        value: function animate() {
            var self = this;
            var h = 1080;
            var svgPosition = this.svgElement.position().top;
            var progress = window.pageYOffset - svgPosition + h;
            this.keyframes.forEach(function (keyframe, scopeIndex) {
                var from = self.resizeBreakpointsToMedia(0, keyframe.from).y;
                var to = self.resizeBreakpointsToMedia(0, keyframe.to).y;
                if (keyframe.interpolate) {
                    var percent = 0;
                    // start default value
                    if (progress < from) {
                        percent = 0;
                    }
                    // all values inbetween
                    if (progress >= from && progress <= to) {
                        var totalLength = to - from;
                        var progressFromStart = progress - from;
                        var openPercent = progressFromStart * 100 / totalLength;
                        percent = Math.min(Math.max(0, openPercent), 100) / 100;
                    }
                    // end default value
                    if (progress > to) {
                        percent = 1;
                    }
                    //console.log('from', from, 'to', to, 'progress', progress, 'percent', percent);
                    keyframe.interpolate(self.d3Svg, self.scopes[scopeIndex], percent);
                } else {
                    //console.log('position', keyframe.position, 'progress', progress, 'remove', keyframe.remove);
                    if (progress >= keyframe.position && !keyframe.running) {
                        var animatedElement = keyframe.animate(self.d3Svg, self.scopes[scopeIndex]);
                        if (keyframe.remove) {
                            animatedElement.on('end', function () {
                                this.remove();
                            });
                        }
                        keyframe.running = true;
                    }
                }
            });
        }
    }, {
        key: 'destroy',
        value: function destroy() {}
    }, {
        key: 'resizeBreakpointsToMedia',
        value: function resizeBreakpointsToMedia(x, y) {
            var factor = 1.115;
            if (Foundation.MediaQuery.current === 'medium') {
                factor = 0.84;
            }
            if (Foundation.MediaQuery.current === 'small') {
                factor = 0.72;
            }

            return {
                x: x * factor,
                y: y * factor
            };
        }
    }], [{
        key: 'easeOutElastic',
        value: function easeOutElastic(t) {
            var p = 0.4;
            return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
        }
    }]);

    return AnimatedSheet;
}();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var positionHelper = __webpack_require__(3);
var popupIcons = __webpack_require__(4);
var pathAnimation = __webpack_require__(5);
var animatedSheet = __webpack_require__(0);

var firstAnimation = __webpack_require__(6);
var secondAnimation = __webpack_require__(7);
var thirdAnimation = __webpack_require__(8);

$(document).foundation();

// TODO: generalize svg attribute initialization somewhere
/*var screenWidth = 1920;
var screenHeight = 2000;
var positionShiftX = 0;
var positionShiftY = -(1/(window.innerWidth))*100*100*25;
var viewboxValue = positionShiftX+' '+positionShiftY+' '+screenWidth+' '+screenHeight;

var d3Svg = d3
    .select('#svg-1')
    .attr('width', '100%')
    .attr('height', '2000')
    .attr('viewBox', viewboxValue)
    .attr('preserveAspectRatio', 'xMinYMin meet');*/

var path1 = new pathAnimation();
var icons1 = new popupIcons();

var sheet1 = firstAnimation;
var sheet2 = secondAnimation;
var sheet3 = thirdAnimation;

d3.select(window).on('scroll.scroller', function () {
    path1.animate();
    icons1.animate();
    sheet1.animate();
    sheet2.animate();
    sheet3.animate();
});

//var helper = new positionHelper().show();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Helper that shows x/y position of the cursor
module.exports = function () {
    function PositionHelper() {
        _classCallCheck(this, PositionHelper);

        this.positionDisplay = d3.select('body').append('div').attr('data-allow-html', true).attr('class', 'tooltip top').style('display', 'none');
        this.centerOffsetDisplay = d3.select('body').append('div').attr('class', 'tooltip right').style('display', 'none');
        this.scrollDisplay = d3.select('body').append('span').attr('class', 'tooltip bottom').style('width', '200px').style('text-align', 'center').style('display', 'none');
    }

    _createClass(PositionHelper, [{
        key: 'show',
        value: function show() {
            var self = this;

            d3.select(window).on('mousemove', function () {
                self.positionDisplay.html('x: ' + d3.event.pageX + '<br /> y: ' + d3.event.pageY).style('top', d3.event.pageY - 100 + 'px').style('left', d3.event.pageX - 34 + 'px').style('display', 'inline');
                var centerOffset = d3.event.pageX - window.innerWidth / 2;
                self.centerOffsetDisplay.html('center: ' + centerOffset).style('top', d3.event.pageY - 25 + 'px').style('left', d3.event.pageX + 35 + 'px').style('display', 'inline');
            });

            d3.select(window).on('scroll', function () {
                self.scrollDisplay.html('scroll: ' + window.pageYOffset).style('top', window.pageYOffset + 100 + 'px').style('left', $(window).width() - 200 + 'px').style('display', 'inline');
            });
        }
    }]);

    return PositionHelper;
}();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// CSS Icon Animations
module.exports = function () {
    function PopupIcons() {
        _classCallCheck(this, PopupIcons);
    }

    _createClass(PopupIcons, [{
        key: 'init',
        value: function init() {
            window.addEventListener('pathEnd', this.animate);
        }
    }, {
        key: 'animate',
        value: function animate() {
            var animatedElements = $('.animated:visible');

            animatedElements.each(function (index, element) {
                // Popup animation triggered when icon is scrolled into view
                if ($(element).attr('class').indexOf('animate-popup') === -1 && $(element).attr('class').indexOf('animate-view-popup') !== -1) {
                    var viewportTop = $(document).scrollTop();
                    var viewportBottom = viewportTop + $(window).height();
                    var elementTop = Math.round($(element).offset().top);
                    if (elementTop + 300 < viewportBottom) {
                        $(element).addClass('animate-popup');
                    }
                }
            });
        }
    }]);

    return PopupIcons;
}();

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Scroll bound line animation
//import * as d3 from "d3";
//var d3 = require("d3");

module.exports = function () {
    function PathAnimation() {
        _classCallCheck(this, PathAnimation);

        var w = 1920; // resolution the viewbox scaling is based on
        var h = 1080;

        var svg = d3.select('#svg-1');

        var path = [[w / 2 - 5, 200], [w / 2 + 30, 300], [w / 2 - 70, 400], [w / 2 + 100, 520], [w / 2 - 100, 620], [w / 2 - 960, 660], [w / 2 - 940, 390], [w / 2 + 50, 450], [w / 2 + 160, 1410], [w / 2 + 190, 1410], [w / 2 + 450, 1300], [w / 2 + 500, 1300], [w / 2 + 1000, 5000]];

        var bezierLine = d3.line().x(function (d) {
            return d[0];
        }).y(function (d) {
            return d[1];
        }).curve(d3.curveBasis);

        this.progress = 0;

        this.stroke = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-linecap', 'round').attr('stroke-dasharray', function () {
            var strokeLength = this.getTotalLength();
            this.progress = this.getTotalLength() - window.pageYOffset;
            return strokeLength + ' ' + strokeLength;
        }).attr('stroke-dashoffset', function () {
            return this.getTotalLength() - window.pageYOffset;
        });
    }

    _createClass(PathAnimation, [{
        key: 'animate',
        value: function animate() {
            this.stroke.attr('stroke-dashoffset', function () {
                var posY = window.pageYOffset;
                //var forwardOnlyProgress = Math.min(progress, this.getTotalLength()-posY);
                //var progressWithLimit = Math.max(0, forwardOnlyProgress);
                var lineSpeed = 4;
                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 9;
                }
                if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 20;
                }
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('pathEnd');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }]);

    return PathAnimation;
}();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// First animation
var AnimatedSheet = __webpack_require__(0);

module.exports = new AnimatedSheet('#svg-1', {
    keyframes: [{
        from: 1627,
        to: 2023,
        remove: false,
        create: function create(svg) {
            this.element = svg.append('g').attr('class', 'bar').attr('transform', 'translate(' + (960 - 300) + ', 1400)').append('rect').attr('width', 600).attr('height', 50).attr('opacity', 1).attr('fill', '#FFFFFF');

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var rotation = d3.interpolateNumber(0, 90);
            return svg.select('.bar rect').attr('transform', 'rotate(' + rotation(AnimatedSheet.easeOutElastic(interpolatePercent)) + ', 300, 25)');
        }
    }, {
        from: 1627,
        to: 2140,
        remove: true,
        create: function create(svg) {
            this.trajectoryPoints = [[960 - 275, 1355], [1920 - 50, 1000], [960 - 300, 3200]];
            this.trailcurve = d3.line().curve(d3.curveCatmullRom);
            this.trajectory = svg.selectAll('line').data(this.trajectoryPoints).enter().append('path').attr('d', this.trailcurve(this.trajectoryPoints)).attr('fill', 'none');
            this.element = svg.select('#icon-clipboard');

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            function translateAlong(path, percent) {
                var l = path.getTotalLength();
                var p = path.getPointAtLength(percent * l);
                return 'translate(' + (p.x - 40) + ', ' + (p.y - 36) + ')';
            }
            var rotation = d3.interpolateNumber(0, 360);

            return createScope.element.attr('transform', translateAlong(createScope.trajectory.node(), interpolatePercent) + 'rotate(' + rotation(interpolatePercent) + ', 30, 25)');
        }
    }, {
        from: 1627,
        to: 2240,
        remove: true,
        create: function create(svg) {
            this.trajectoryPoints = [[960 - 80, 1365], [1920 - 55, 1100], [960 - 300, 3000]];
            this.trailcurve = d3.line().curve(d3.curveCatmullRom);
            this.trajectory = svg.selectAll('line').data(this.trajectoryPoints).enter().append('path').attr('d', this.trailcurve(this.trajectoryPoints)).attr('fill', 'none');
            this.element = svg.select('#icon-database');

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            function translateAlong(path, percent) {
                var l = path.getTotalLength();
                var p = path.getPointAtLength(percent * l);
                return 'translate(' + (p.x - 40) + ', ' + (p.y - 36) + ')';
            }
            var rotation = d3.interpolateNumber(0, 360);

            return createScope.element.attr('transform', translateAlong(createScope.trajectory.node(), interpolatePercent) + 'rotate(' + rotation(interpolatePercent) + ', 30, 25)');
        }
    }, {
        from: 1627,
        to: 2240,
        remove: true,
        create: function create(svg) {
            this.element = svg.select('#icon-cloud');

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var arc = d3.interpolateObject({ x: 960 + 100 - 40,
                y: 1333
            }, {
                x: 1920 - 600,
                y: 3000
            });
            var pos = arc(interpolatePercent);
            return svg.select('#icon-cloud').attr('transform', 'translate(' + pos.x + ', ' + pos.y + ')');
        }
    }, {
        from: 1627,
        to: 2240,
        remove: true,
        create: function create(svg) {
            this.element = svg.select('#icon-app');

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var arc = d3.interpolateObject({ x: 960 + 300 - 70,
                y: 1325
            }, {
                x: 1920 - 300,
                y: 3200
            });
            var pos = arc(interpolatePercent);
            return svg.select('#icon-app').attr('transform', 'translate(' + pos.x + ', ' + pos.y + ')');
        }
    }]
});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Second animation
var AnimatedSheet = __webpack_require__(0);

module.exports = new AnimatedSheet('#svg-2', {
    keyframes: [{
        from: 0,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var path = [[w / 2 + 800, -150], [w / 2 + 800, 600], [w / 2 + 100, 600], [w / 2 - 280, 980], [w / 2 - 500, 1200], [w / 2 - 500, 2150]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none')
            //.attr('stroke-linecap', 'round')
            .attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            this.element.attr('stroke-dashoffset', function () {
                var startY = $(svg.node()).offset().top;
                var posY = Math.max(0, window.pageYOffset + window.innerHeight / 2 - startY);
                var lineSpeed = 1.5;

                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 4;
                }
                if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 5;
                }
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 1450,
        to: 1550,
        remove: false,
        create: function create(svg) {
            this.element = svg.select('#chip').attr('z-index', 99).moveToFront();

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var color = d3.interpolate('gray', 'white');
            return this.element.style('fill', color(interpolatePercent));
        }
    }, {
        from: 0,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var path = [[w / 2 - 230, 1000], [w / 2 - 450, 1220], [w / 2 - 450, 2150]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            this.element.attr('stroke-dashoffset', function () {
                var svgY = $(svg.node()).offset().top;

                var lineSpeed = 1.5;
                var startY = svgY + 900;
                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 3.90;
                    startY = svgY + 100;
                } else if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 4;
                    startY = svgY;
                }

                var posY = Math.max(0, window.pageYOffset - startY);
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 1550,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var path = [[w / 2 - 160, 1000], [w / 2 - 400, 1250], [w / 2 - 400, 2150]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var self = this;
            this.element.attr('stroke-dashoffset', function () {
                var svgY = $(svg.node()).offset().top;

                var lineSpeed = 1.5;
                var startY = svgY + 900;
                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 3.90;
                    startY = svgY + 100;
                } else if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 4;
                    startY = svgY - 50;
                }

                var posY = Math.max(0, window.pageYOffset - startY);
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 1550,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var path = [[w / 2 - 120, 1030], [w / 2 - 350, 1270], [w / 2 - 350, 2150]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var self = this;
            this.element.attr('stroke-dashoffset', function () {
                var svgY = $(svg.node()).offset().top;

                var lineSpeed = 1.5;
                var startY = svgY + 900;
                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 3.90;
                    startY = svgY + 100;
                } else if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 4;
                    startY = svgY - 50;
                }

                var posY = Math.max(0, window.pageYOffset - startY);
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }]
});

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Third animation
var AnimatedSheet = __webpack_require__(0);

module.exports = new AnimatedSheet('#svg-3', {
    defs: [
    // TODO: is a filter independently usable for multiple elements?
    {
        filter: function filter(svg) {
            return svg.append("defs").append("filter").attr("id", "motionFilter1").append("feGaussianBlur").attr("class", "blurValues1").attr("in", "SourceGraphic").attr("stdDeviation", "10 10");
        }
    }, {
        filter: function filter(svg) {
            return svg.append("defs").append("filter").attr("id", "motionFilter2").append("feGaussianBlur").attr("class", "blurValues2").attr("in", "SourceGraphic").attr("stdDeviation", "10 10");
        }
    }, {
        filter: function filter(svg) {
            return svg.append("defs").append("filter").attr("id", "motionFilter3").append("feGaussianBlur").attr("class", "blurValues3").attr("in", "SourceGraphic").attr("stdDeviation", "10 10");
        }
    }, {
        filter: function filter(svg) {
            return svg.append("defs").append("filter").attr("id", "motionFilter4").append("feGaussianBlur").attr("class", "blurValues4").attr("in", "SourceGraphic").attr("stdDeviation", "10 10");
        }
    }],
    keyframes: [{
        from: 0,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var h = 1080;
            var path = [[w / 2 - 500, -150], [w / 2 - 500, 150], [w / 2 - 810, 150], [w / 2 - 810, 480], [w / 2 - 580, 480], [w / 2 - 580, 2000]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-linecap', 'round').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var self = this;
            this.element.attr('stroke-dashoffset', function () {
                var startY = $(svg.node()).offset().top - window.innerHeight / 3;
                var posY = Math.max(0, window.pageYOffset - startY);
                var lineSpeed = 1.6;

                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 4;
                }
                if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 7;
                }
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 0,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var h = 1080;
            var path = [[w / 2 - 450, -150], [w / 2 - 450, 20], [w / 2 - 240, 20], [w / 2 - 240, 950], [w / 2 - 520, 950], [w / 2 - 520, 1280], [w / 2 - 70, 1280], [w / 2 - 620, 2000]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-linecap', 'round').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            //return;
            var self = this;
            this.element.attr('stroke-dashoffset', function () {
                var startY = $(svg.node()).offset().top - window.innerHeight / 3;
                var posY = Math.max(0, window.pageYOffset - startY);
                var lineSpeed = 1.95;

                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 4;
                }
                if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 7;
                }
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 0,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var h = 1080;
            var path = [[w / 2 - 400, -150], [w / 2 - 400, -80], [w / 2 - 400, -30], [w / 2 - 200, -30], [w / 2 + 150, -30], [w / 2 + 150, 1350], [w / 2 + 490, 1350], [w / 2 + 490, 1680], [w / 2 + 40, 1680], [w / 2 - 750, 2000]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-linecap', 'round').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            //return;
            var self = this;
            this.element.attr('stroke-dashoffset', function () {
                var startY = $(svg.node()).offset().top - window.innerHeight / 3;
                var posY = Math.max(0, window.pageYOffset - startY);
                var lineSpeed = 2.31;

                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 4;
                }
                if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 7;
                }
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 0,
        to: 2000,
        remove: false,
        create: function create(svg) {
            var w = 1920; // resolution the viewbox scaling is based on
            var h = 1080;
            var path = [[w / 2 - 350, -150], [w / 2 - 350, -80], [w / 2 + 200, -80], [w / 2 + 200, 550], [w / 2 + 690, 550], [w / 2 + 690, 1730], [w / 2 - 1120, 2000]];
            var bezierLine = d3.line().x(function (d) {
                return d[0];
            }).y(function (d) {
                return d[1];
            });

            this.progress = 0;

            this.element = svg.selectAll('line').data([window.pageYOffset]).enter().append('path').attr('d', bezierLine(path)).attr('stroke', '#FFFFFF').attr('stroke-width', 10).attr('fill', 'none').attr('stroke-linecap', 'round').attr('stroke-dasharray', function () {
                var strokeLength = this.getTotalLength();
                this.progress = this.getTotalLength() - window.pageYOffset;
                return strokeLength + ' ' + strokeLength;
            }).attr('stroke-dashoffset', function () {
                return this.getTotalLength() - window.pageYOffset;
            });

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            //return;
            var self = this;
            this.element.attr('stroke-dashoffset', function () {
                var startY = $(svg.node()).offset().top - window.innerHeight / 3;
                var posY = Math.max(0, window.pageYOffset - startY);
                var lineSpeed = 2.46;

                if (Foundation.MediaQuery.current === 'medium') {
                    lineSpeed = 4;
                }
                if (Foundation.MediaQuery.current === 'small') {
                    lineSpeed = 7;
                }
                var progress = this.getTotalLength() - posY * lineSpeed;

                // event when path has reached its full length
                if (progress < 0) {
                    var endEvent = new Event('path2End');
                    window.dispatchEvent(endEvent);
                }

                return progress;
            });
        }
    }, {
        from: 750,
        to: 950,
        remove: false,
        create: function create(svg) {
            this.element = svg.selectAll('#path-image-1').attr("filter", "url(#motionFilter1)").attr("opacity", 0);

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var self = this;
            var transitionInterpolator = d3.interpolateNumber(400, 200);
            var opacityInterpolator = d3.interpolateNumber(0, 1);
            this.element.attr('visibility', 'visible').attr("transform", "translate(" + transitionInterpolator(interpolatePercent) + ", 200)").attr("opacity", opacityInterpolator(interpolatePercent));

            var blurInterpolator = d3.interpolateString("10 10", "0 0");
            d3.select("#motionFilter1 .blurValues1").attr("stdDeviation", blurInterpolator(interpolatePercent));
        }
    }, {
        from: 1050,
        to: 1250,
        remove: false,
        create: function create(svg) {
            this.element = svg.selectAll('#path-image-2').attr("filter", "url(#motionFilter2)").attr("opacity", 0);

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var transitionInterpolator = d3.interpolateNumber(1000, 1200);
            var opacityInterpolator = d3.interpolateNumber(0, 1);
            var blurInterpolator = d3.interpolateString("10 10", "0 0");

            this.element.attr('visibility', 'visible').attr("transform", "translate(" + transitionInterpolator(interpolatePercent) + ", 600)").attr("opacity", opacityInterpolator(interpolatePercent));

            d3.select("#motionFilter2 .blurValues2").attr("stdDeviation", blurInterpolator(interpolatePercent));
        }
    }, {
        from: 1150,
        to: 1350,
        remove: false,
        create: function create(svg) {
            this.element = svg.selectAll('#path-image-3').attr("filter", "url(#motionFilter3)").attr("opacity", 0);

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var transitionInterpolator = d3.interpolateNumber(700, 500);
            var opacityInterpolator = d3.interpolateNumber(0, 1);
            var blurInterpolator = d3.interpolateString("10 10", "0 0");

            this.element.attr('visibility', 'visible').attr("transform", "translate(" + transitionInterpolator(interpolatePercent) + ", 1000)").attr("opacity", opacityInterpolator(interpolatePercent));
            d3.select("#motionFilter3 .blurValues3").attr("stdDeviation", blurInterpolator(interpolatePercent));
        }
    }, {
        from: 1350,
        to: 1550,
        remove: false,
        create: function create(svg) {
            this.element = svg.selectAll('#path-image-4').attr("filter", "url(#motionFilter4)").attr("opacity", 0);

            return this;
        },
        interpolate: function interpolate(svg, createScope, interpolatePercent) {
            var transitionInterpolator = d3.interpolateNumber(800, 1000);
            var opacityInterpolator = d3.interpolateNumber(0, 1);
            var blurInterpolator = d3.interpolateString("10 10", "0 0");

            this.element.attr('visibility', 'visible').attr("transform", "translate(" + transitionInterpolator(interpolatePercent) + ", 1400)").attr("opacity", opacityInterpolator(interpolatePercent));

            d3.select("#motionFilter4 .blurValues4").attr("stdDeviation", blurInterpolator(interpolatePercent));
        }
    }]
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDViODU2Yzk4ZjgzZDE5OWUzYjUiLCJ3ZWJwYWNrOi8vLy4vanMvYW5pbWF0ZWQtc2hlZXQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvYXBwLmpzIiwid2VicGFjazovLy8uL2pzL3Bvc2l0aW9uLWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9wb3B1cC1pY29ucy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9wYXRoLWFuaW1hdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvYW5pbWF0aW9uLTEuanMiLCJ3ZWJwYWNrOi8vLy4vanMvYW5pbWF0aW9uLTIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvYW5pbWF0aW9uLTMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQTs7QUFFQSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUMsRzs7Ozs7Ozs7Ozs7Ozs7QUN0S0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDJDOzs7Ozs7O0FDMUNBOztBQUVBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDLEc7Ozs7Ozs7QUNsQ0Q7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQyxHOzs7Ozs7O0FDckNEOztBQUVBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDLEc7Ozs7Ozs7QUNsRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLEU7Ozs7Ozs7QUN0R0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDLEU7Ozs7Ozs7QUNqT0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRSIsImZpbGUiOiJhcHAubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZDViODU2Yzk4ZjgzZDE5OWUzYjUiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vaW1wb3J0ICdmb3VuZGF0aW9uLXNpdGVzL2pzL2ZvdW5kYXRpb24uY29yZSc7XG4vL2ltcG9ydCAnZm91bmRhdGlvbi1zaXRlcy9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSc7XG5cbi8vIEFuaW1hdGVkIHN2ZyBzZWN0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0ZWRTaGVldChzdmdTZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0ZWRTaGVldCk7XG5cbiAgICAgICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlVG9Gcm9udCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudCA9ICQoc3ZnU2VsZWN0b3IpO1xuICAgICAgICAvL2lmKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAvLyAgICB0aGlzLnN2ZyA9IHN2Z0VsZW1lbnQ7XG4gICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnN2Z0VsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBzdmcgZm91bmQgYnkgc2VsZWN0b3IgXCInICsgc3ZnU2VsZWN0b3IgKyAnXCInKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZDNTdmcgPSBkMy5zZWxlY3Qoc3ZnU2VsZWN0b3IpLmF0dHIoJ3dpZHRoJywgb3B0aW9ucy53aWR0aCA/IG9wdGlvbnMud2lkdGggOiAnMTAwJScpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvL0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICAgIC8vIHJlc2l6ZSB2aWV3Ym94IG9uIHNtYWxsIGRpc3BsYXlzXG4gICAgICAgIHZhciByZWZvcm1hdFZpZXdib3ggPSBmdW5jdGlvbiByZWZvcm1hdFZpZXdib3goKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXRXaWR0aCA9IDE5MjA7XG4gICAgICAgICAgICB2YXIgc2hlZXRIZWlnaHQgPSAxMDgwO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uU2hpZnRYID0gMDtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvblNoaWZ0WSA9IC0oMSAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDEwMCAqIDEwMCAqIDI1O1xuICAgICAgICAgICAgdmFyIHZpZXdib3hWYWx1ZSA9IHBvc2l0aW9uU2hpZnRYICsgJyAnICsgcG9zaXRpb25TaGlmdFkgKyAnICcgKyBzaGVldFdpZHRoICsgJyAnICsgc2hlZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZpZXdib3hWYWx1ZSA9IFwiMCAtMTUwIDE5MjAgMjAwMFwiO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZWZvcm1hdCcsIHBvc2l0aW9uU2hpZnRZKTtcblxuICAgICAgICAgICAgdmFyIHNtYWxsID0gNjQwO1xuICAgICAgICAgICAgdmFyIG1lZGl1bSA9IDEwMjQ7XG5cbiAgICAgICAgICAgIHNlbGYuZDNTdmcuYXR0cignaGVpZ2h0JywgMjAwMCkuYXR0cigndmlld0JveCcsIHZpZXdib3hWYWx1ZSkuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWluWU1pbiBtZWV0Jyk7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cod2luZG93LmlubmVyV2lkdGgsICBtZWRpdW0pO1xuXG4gICAgICAgICAgICAvLyBlbXB0eSB3aGVuIHVzaW5nIHdlYnBhY2sgKGh0dHBzOi8vZ2l0aHViLmNvbS96dXJiL2ZvdW5kYXRpb24tc2l0ZXMvaXNzdWVzLzEwMzYzKTpcbiAgICAgICAgICAgIC8vaWYoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdzbWFsbCcpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8PSBzbWFsbCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NldHRpbmcgc2hlZXQgdG8gc21hbGwnKTtcbiAgICAgICAgICAgICAgICBzZWxmLmQzU3ZnLmF0dHIoJ2hlaWdodCcsIDY2Nyk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAvL2lmKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50ID09PSAnbWVkaXVtJykge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8PSBtZWRpdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0dGluZyBzaGVldCB0byBtZWRpdW0nKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kM1N2Zy5hdHRyKCdoZWlnaHQnLCAxMDI0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zY29wZXMgPSBbXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWZzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi5maWx0ZXIoc2VsZi5kM1N2Zyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBvcHRpb25zLmtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlmcmFtZSwgc2NvcGVJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNyZWF0ZVNjb3BlID0ga2V5ZnJhbWUuY3JlYXRlKHNlbGYuZDNTdmcpO1xuICAgICAgICAgICAgaWYgKGNyZWF0ZVNjb3BlLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVTY29wZS5lbGVtZW50LmF0dHIoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBjcmVhdGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgZWxlbWVudCBrZXksIHNvIGl0IGNhbiBiZSBhY2Nlc3NlZCBpbiB0aGUgYW5pbWF0ZS9pbnRlcnBvbGF0ZSBmdW5jdGlvbiB2aWEgdGhlIFwiY3JlYXRlU2NvcGVcIiBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2NvcGVzW3Njb3BlSW5kZXhdID0gY3JlYXRlU2NvcGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZWZvcm1hdFZpZXdib3goKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlZm9ybWF0Vmlld2JveCk7XG4gICAgICAgIC8vfSgpO1xuICAgICAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQW5pbWF0ZWRTaGVldCwgW3tcbiAgICAgICAga2V5OiAnYW5pbWF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGggPSAxMDgwO1xuICAgICAgICAgICAgdmFyIHN2Z1Bvc2l0aW9uID0gdGhpcy5zdmdFbGVtZW50LnBvc2l0aW9uKCkudG9wO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gc3ZnUG9zaXRpb24gKyBoO1xuICAgICAgICAgICAgdGhpcy5rZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5ZnJhbWUsIHNjb3BlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHNlbGYucmVzaXplQnJlYWtwb2ludHNUb01lZGlhKDAsIGtleWZyYW1lLmZyb20pLnk7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gc2VsZi5yZXNpemVCcmVha3BvaW50c1RvTWVkaWEoMCwga2V5ZnJhbWUudG8pLnk7XG4gICAgICAgICAgICAgICAgaWYgKGtleWZyYW1lLmludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgdmFsdWVzIGluYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gZnJvbSAmJiBwcm9ncmVzcyA8PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gdG8gLSBmcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzRnJvbVN0YXJ0ID0gcHJvZ3Jlc3MgLSBmcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5QZXJjZW50ID0gcHJvZ3Jlc3NGcm9tU3RhcnQgKiAxMDAgLyB0b3RhbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBvcGVuUGVyY2VudCksIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Zyb20nLCBmcm9tLCAndG8nLCB0bywgJ3Byb2dyZXNzJywgcHJvZ3Jlc3MsICdwZXJjZW50JywgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIGtleWZyYW1lLmludGVycG9sYXRlKHNlbGYuZDNTdmcsIHNlbGYuc2NvcGVzW3Njb3BlSW5kZXhdLCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwb3NpdGlvbicsIGtleWZyYW1lLnBvc2l0aW9uLCAncHJvZ3Jlc3MnLCBwcm9ncmVzcywgJ3JlbW92ZScsIGtleWZyYW1lLnJlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSBrZXlmcmFtZS5wb3NpdGlvbiAmJiAha2V5ZnJhbWUucnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVkRWxlbWVudCA9IGtleWZyYW1lLmFuaW1hdGUoc2VsZi5kM1N2Zywgc2VsZi5zY29wZXNbc2NvcGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleWZyYW1lLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWUucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2l6ZUJyZWFrcG9pbnRzVG9NZWRpYScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVCcmVha3BvaW50c1RvTWVkaWEoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9IDEuMTE1O1xuICAgICAgICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50ID09PSAnbWVkaXVtJykge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9IDAuODQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdzbWFsbCcpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSAwLjcyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHggKiBmYWN0b3IsXG4gICAgICAgICAgICAgICAgeTogeSAqIGZhY3RvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdlYXNlT3V0RWxhc3RpYycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcCAvIDQpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBbmltYXRlZFNoZWV0O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvYW5pbWF0ZWQtc2hlZXQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zaXRpb25IZWxwZXIgPSByZXF1aXJlKCcuL3Bvc2l0aW9uLWhlbHBlcicpO1xudmFyIHBvcHVwSWNvbnMgPSByZXF1aXJlKCcuL3BvcHVwLWljb25zJyk7XG52YXIgcGF0aEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vcGF0aC1hbmltYXRpb25zJyk7XG52YXIgYW5pbWF0ZWRTaGVldCA9IHJlcXVpcmUoJy4vYW5pbWF0ZWQtc2hlZXQnKTtcblxudmFyIGZpcnN0QW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24tMScpO1xudmFyIHNlY29uZEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uLTInKTtcbnZhciB0aGlyZEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uLTMnKTtcblxuJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xuXG4vLyBUT0RPOiBnZW5lcmFsaXplIHN2ZyBhdHRyaWJ1dGUgaW5pdGlhbGl6YXRpb24gc29tZXdoZXJlXG4vKnZhciBzY3JlZW5XaWR0aCA9IDE5MjA7XG52YXIgc2NyZWVuSGVpZ2h0ID0gMjAwMDtcbnZhciBwb3NpdGlvblNoaWZ0WCA9IDA7XG52YXIgcG9zaXRpb25TaGlmdFkgPSAtKDEvKHdpbmRvdy5pbm5lcldpZHRoKSkqMTAwKjEwMCoyNTtcbnZhciB2aWV3Ym94VmFsdWUgPSBwb3NpdGlvblNoaWZ0WCsnICcrcG9zaXRpb25TaGlmdFkrJyAnK3NjcmVlbldpZHRoKycgJytzY3JlZW5IZWlnaHQ7XG5cbnZhciBkM1N2ZyA9IGQzXG4gICAgLnNlbGVjdCgnI3N2Zy0xJylcbiAgICAuYXR0cignd2lkdGgnLCAnMTAwJScpXG4gICAgLmF0dHIoJ2hlaWdodCcsICcyMDAwJylcbiAgICAuYXR0cigndmlld0JveCcsIHZpZXdib3hWYWx1ZSlcbiAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWluWU1pbiBtZWV0Jyk7Ki9cblxudmFyIHBhdGgxID0gbmV3IHBhdGhBbmltYXRpb24oKTtcbnZhciBpY29uczEgPSBuZXcgcG9wdXBJY29ucygpO1xuXG52YXIgc2hlZXQxID0gZmlyc3RBbmltYXRpb247XG52YXIgc2hlZXQyID0gc2Vjb25kQW5pbWF0aW9uO1xudmFyIHNoZWV0MyA9IHRoaXJkQW5pbWF0aW9uO1xuXG5kMy5zZWxlY3Qod2luZG93KS5vbignc2Nyb2xsLnNjcm9sbGVyJywgZnVuY3Rpb24gKCkge1xuICAgIHBhdGgxLmFuaW1hdGUoKTtcbiAgICBpY29uczEuYW5pbWF0ZSgpO1xuICAgIHNoZWV0MS5hbmltYXRlKCk7XG4gICAgc2hlZXQyLmFuaW1hdGUoKTtcbiAgICBzaGVldDMuYW5pbWF0ZSgpO1xufSk7XG5cbi8vdmFyIGhlbHBlciA9IG5ldyBwb3NpdGlvbkhlbHBlcigpLnNob3coKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2FwcC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIEhlbHBlciB0aGF0IHNob3dzIHgveSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3NpdGlvbkhlbHBlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc2l0aW9uSGVscGVyKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uRGlzcGxheSA9IGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JykuYXR0cignZGF0YS1hbGxvdy1odG1sJywgdHJ1ZSkuYXR0cignY2xhc3MnLCAndG9vbHRpcCB0b3AnKS5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgIHRoaXMuY2VudGVyT2Zmc2V0RGlzcGxheSA9IGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAndG9vbHRpcCByaWdodCcpLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgdGhpcy5zY3JvbGxEaXNwbGF5ID0gZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdzcGFuJykuYXR0cignY2xhc3MnLCAndG9vbHRpcCBib3R0b20nKS5zdHlsZSgnd2lkdGgnLCAnMjAwcHgnKS5zdHlsZSgndGV4dC1hbGlnbicsICdjZW50ZXInKS5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBvc2l0aW9uSGVscGVyLCBbe1xuICAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdCh3aW5kb3cpLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbkRpc3BsYXkuaHRtbCgneDogJyArIGQzLmV2ZW50LnBhZ2VYICsgJzxiciAvPiB5OiAnICsgZDMuZXZlbnQucGFnZVkpLnN0eWxlKCd0b3AnLCBkMy5ldmVudC5wYWdlWSAtIDEwMCArICdweCcpLnN0eWxlKCdsZWZ0JywgZDMuZXZlbnQucGFnZVggLSAzNCArICdweCcpLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJPZmZzZXQgPSBkMy5ldmVudC5wYWdlWCAtIHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBzZWxmLmNlbnRlck9mZnNldERpc3BsYXkuaHRtbCgnY2VudGVyOiAnICsgY2VudGVyT2Zmc2V0KS5zdHlsZSgndG9wJywgZDMuZXZlbnQucGFnZVkgLSAyNSArICdweCcpLnN0eWxlKCdsZWZ0JywgZDMuZXZlbnQucGFnZVggKyAzNSArICdweCcpLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxEaXNwbGF5Lmh0bWwoJ3Njcm9sbDogJyArIHdpbmRvdy5wYWdlWU9mZnNldCkuc3R5bGUoJ3RvcCcsIHdpbmRvdy5wYWdlWU9mZnNldCArIDEwMCArICdweCcpLnN0eWxlKCdsZWZ0JywgJCh3aW5kb3cpLndpZHRoKCkgLSAyMDAgKyAncHgnKS5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBvc2l0aW9uSGVscGVyO1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvcG9zaXRpb24taGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gQ1NTIEljb24gQW5pbWF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9wdXBJY29ucygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHVwSWNvbnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQb3B1cEljb25zLCBbe1xuICAgICAgICBrZXk6ICdpbml0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGF0aEVuZCcsIHRoaXMuYW5pbWF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuaW1hdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRlZEVsZW1lbnRzID0gJCgnLmFuaW1hdGVkOnZpc2libGUnKTtcblxuICAgICAgICAgICAgYW5pbWF0ZWRFbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFBvcHVwIGFuaW1hdGlvbiB0cmlnZ2VyZWQgd2hlbiBpY29uIGlzIHNjcm9sbGVkIGludG8gdmlld1xuICAgICAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmF0dHIoJ2NsYXNzJykuaW5kZXhPZignYW5pbWF0ZS1wb3B1cCcpID09PSAtMSAmJiAkKGVsZW1lbnQpLmF0dHIoJ2NsYXNzJykuaW5kZXhPZignYW5pbWF0ZS12aWV3LXBvcHVwJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydFRvcCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRCb3R0b20gPSB2aWV3cG9ydFRvcCArICQod2luZG93KS5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRUb3AgPSBNYXRoLnJvdW5kKCQoZWxlbWVudCkub2Zmc2V0KCkudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUb3AgKyAzMDAgPCB2aWV3cG9ydEJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcygnYW5pbWF0ZS1wb3B1cCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9wdXBJY29ucztcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL3BvcHVwLWljb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gU2Nyb2xsIGJvdW5kIGxpbmUgYW5pbWF0aW9uXG4vL2ltcG9ydCAqIGFzIGQzIGZyb20gXCJkM1wiO1xuLy92YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGhBbmltYXRpb24oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXRoQW5pbWF0aW9uKTtcblxuICAgICAgICB2YXIgdyA9IDE5MjA7IC8vIHJlc29sdXRpb24gdGhlIHZpZXdib3ggc2NhbGluZyBpcyBiYXNlZCBvblxuICAgICAgICB2YXIgaCA9IDEwODA7XG5cbiAgICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgnI3N2Zy0xJyk7XG5cbiAgICAgICAgdmFyIHBhdGggPSBbW3cgLyAyIC0gNSwgMjAwXSwgW3cgLyAyICsgMzAsIDMwMF0sIFt3IC8gMiAtIDcwLCA0MDBdLCBbdyAvIDIgKyAxMDAsIDUyMF0sIFt3IC8gMiAtIDEwMCwgNjIwXSwgW3cgLyAyIC0gOTYwLCA2NjBdLCBbdyAvIDIgLSA5NDAsIDM5MF0sIFt3IC8gMiArIDUwLCA0NTBdLCBbdyAvIDIgKyAxNjAsIDE0MTBdLCBbdyAvIDIgKyAxOTAsIDE0MTBdLCBbdyAvIDIgKyA0NTAsIDEzMDBdLCBbdyAvIDIgKyA1MDAsIDEzMDBdLCBbdyAvIDIgKyAxMDAwLCA1MDAwXV07XG5cbiAgICAgICAgdmFyIGJlemllckxpbmUgPSBkMy5saW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICB9KS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKTtcblxuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcblxuICAgICAgICB0aGlzLnN0cm9rZSA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUnKS5kYXRhKFt3aW5kb3cucGFnZVlPZmZzZXRdKS5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBiZXppZXJMaW5lKHBhdGgpKS5hdHRyKCdzdHJva2UnLCAnI0ZGRkZGRicpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEwKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlTGVuZ3RoID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiBzdHJva2VMZW5ndGggKyAnICcgKyBzdHJva2VMZW5ndGg7XG4gICAgICAgIH0pLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBhdGhBbmltYXRpb24sIFt7XG4gICAgICAgIGtleTogJ2FuaW1hdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vdmFyIGZvcndhcmRPbmx5UHJvZ3Jlc3MgPSBNYXRoLm1pbihwcm9ncmVzcywgdGhpcy5nZXRUb3RhbExlbmd0aCgpLXBvc1kpO1xuICAgICAgICAgICAgICAgIC8vdmFyIHByb2dyZXNzV2l0aExpbWl0ID0gTWF0aC5tYXgoMCwgZm9yd2FyZE9ubHlQcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVTcGVlZCA9IDQ7XG4gICAgICAgICAgICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50ID09PSAnbWVkaXVtJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3BlZWQgPSA5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdzbWFsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVNwZWVkID0gMjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHBvc1kgKiBsaW5lU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudCB3aGVuIHBhdGggaGFzIHJlYWNoZWQgaXRzIGZ1bGwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBuZXcgRXZlbnQoJ3BhdGhFbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBhdGhBbmltYXRpb247XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9wYXRoLWFuaW1hdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBGaXJzdCBhbmltYXRpb25cbnZhciBBbmltYXRlZFNoZWV0ID0gcmVxdWlyZShcIi4vYW5pbWF0ZWQtc2hlZXRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEFuaW1hdGVkU2hlZXQoJyNzdmctMScsIHtcbiAgICBrZXlmcmFtZXM6IFt7XG4gICAgICAgIGZyb206IDE2MjcsXG4gICAgICAgIHRvOiAyMDIzLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdiYXInKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoOTYwIC0gMzAwKSArICcsIDE0MDApJykuYXBwZW5kKCdyZWN0JykuYXR0cignd2lkdGgnLCA2MDApLmF0dHIoJ2hlaWdodCcsIDUwKS5hdHRyKCdvcGFjaXR5JywgMSkuYXR0cignZmlsbCcsICcjRkZGRkZGJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3ZnLCBjcmVhdGVTY29wZSwgaW50ZXJwb2xhdGVQZXJjZW50KSB7XG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSBkMy5pbnRlcnBvbGF0ZU51bWJlcigwLCA5MCk7XG4gICAgICAgICAgICByZXR1cm4gc3ZnLnNlbGVjdCgnLmJhciByZWN0JykuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgnICsgcm90YXRpb24oQW5pbWF0ZWRTaGVldC5lYXNlT3V0RWxhc3RpYyhpbnRlcnBvbGF0ZVBlcmNlbnQpKSArICcsIDMwMCwgMjUpJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDE2MjcsXG4gICAgICAgIHRvOiAyMTQwLFxuICAgICAgICByZW1vdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN2Zykge1xuICAgICAgICAgICAgdGhpcy50cmFqZWN0b3J5UG9pbnRzID0gW1s5NjAgLSAyNzUsIDEzNTVdLCBbMTkyMCAtIDUwLCAxMDAwXSwgWzk2MCAtIDMwMCwgMzIwMF1dO1xuICAgICAgICAgICAgdGhpcy50cmFpbGN1cnZlID0gZDMubGluZSgpLmN1cnZlKGQzLmN1cnZlQ2F0bXVsbFJvbSk7XG4gICAgICAgICAgICB0aGlzLnRyYWplY3RvcnkgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YSh0aGlzLnRyYWplY3RvcnlQb2ludHMpLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHRoaXMudHJhaWxjdXJ2ZSh0aGlzLnRyYWplY3RvcnlQb2ludHMpKS5hdHRyKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3QoJyNpY29uLWNsaXBib2FyZCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN2ZywgY3JlYXRlU2NvcGUsIGludGVycG9sYXRlUGVyY2VudCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlQWxvbmcocGF0aCwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBwID0gcGF0aC5nZXRQb2ludEF0TGVuZ3RoKHBlcmNlbnQgKiBsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKHAueCAtIDQwKSArICcsICcgKyAocC55IC0gMzYpICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoMCwgMzYwKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNjb3BlLmVsZW1lbnQuYXR0cigndHJhbnNmb3JtJywgdHJhbnNsYXRlQWxvbmcoY3JlYXRlU2NvcGUudHJhamVjdG9yeS5ub2RlKCksIGludGVycG9sYXRlUGVyY2VudCkgKyAncm90YXRlKCcgKyByb3RhdGlvbihpbnRlcnBvbGF0ZVBlcmNlbnQpICsgJywgMzAsIDI1KScpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBmcm9tOiAxNjI3LFxuICAgICAgICB0bzogMjI0MCxcbiAgICAgICAgcmVtb3ZlOiB0cnVlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJhamVjdG9yeVBvaW50cyA9IFtbOTYwIC0gODAsIDEzNjVdLCBbMTkyMCAtIDU1LCAxMTAwXSwgWzk2MCAtIDMwMCwgMzAwMF1dO1xuICAgICAgICAgICAgdGhpcy50cmFpbGN1cnZlID0gZDMubGluZSgpLmN1cnZlKGQzLmN1cnZlQ2F0bXVsbFJvbSk7XG4gICAgICAgICAgICB0aGlzLnRyYWplY3RvcnkgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YSh0aGlzLnRyYWplY3RvcnlQb2ludHMpLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHRoaXMudHJhaWxjdXJ2ZSh0aGlzLnRyYWplY3RvcnlQb2ludHMpKS5hdHRyKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3QoJyNpY29uLWRhdGFiYXNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3ZnLCBjcmVhdGVTY29wZSwgaW50ZXJwb2xhdGVQZXJjZW50KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVBbG9uZyhwYXRoLCBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBwYXRoLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYXRoLmdldFBvaW50QXRMZW5ndGgocGVyY2VudCAqIGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAocC54IC0gNDApICsgJywgJyArIChwLnkgLSAzNikgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSBkMy5pbnRlcnBvbGF0ZU51bWJlcigwLCAzNjApO1xuXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2NvcGUuZWxlbWVudC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVBbG9uZyhjcmVhdGVTY29wZS50cmFqZWN0b3J5Lm5vZGUoKSwgaW50ZXJwb2xhdGVQZXJjZW50KSArICdyb3RhdGUoJyArIHJvdGF0aW9uKGludGVycG9sYXRlUGVyY2VudCkgKyAnLCAzMCwgMjUpJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDE2MjcsXG4gICAgICAgIHRvOiAyMjQwLFxuICAgICAgICByZW1vdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN2Zykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gc3ZnLnNlbGVjdCgnI2ljb24tY2xvdWQnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdmcsIGNyZWF0ZVNjb3BlLCBpbnRlcnBvbGF0ZVBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhciBhcmMgPSBkMy5pbnRlcnBvbGF0ZU9iamVjdCh7IHg6IDk2MCArIDEwMCAtIDQwLFxuICAgICAgICAgICAgICAgIHk6IDEzMzNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiAxOTIwIC0gNjAwLFxuICAgICAgICAgICAgICAgIHk6IDMwMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGFyYyhpbnRlcnBvbGF0ZVBlcmNlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHN2Zy5zZWxlY3QoJyNpY29uLWNsb3VkJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgcG9zLnggKyAnLCAnICsgcG9zLnkgKyAnKScpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBmcm9tOiAxNjI3LFxuICAgICAgICB0bzogMjI0MCxcbiAgICAgICAgcmVtb3ZlOiB0cnVlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3QoJyNpY29uLWFwcCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN2ZywgY3JlYXRlU2NvcGUsIGludGVycG9sYXRlUGVyY2VudCkge1xuICAgICAgICAgICAgdmFyIGFyYyA9IGQzLmludGVycG9sYXRlT2JqZWN0KHsgeDogOTYwICsgMzAwIC0gNzAsXG4gICAgICAgICAgICAgICAgeTogMTMyNVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IDE5MjAgLSAzMDAsXG4gICAgICAgICAgICAgICAgeTogMzIwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcG9zID0gYXJjKGludGVycG9sYXRlUGVyY2VudCk7XG4gICAgICAgICAgICByZXR1cm4gc3ZnLnNlbGVjdCgnI2ljb24tYXBwJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgcG9zLnggKyAnLCAnICsgcG9zLnkgKyAnKScpO1xuICAgICAgICB9XG4gICAgfV1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvYW5pbWF0aW9uLTEuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWNvbmQgYW5pbWF0aW9uXG52YXIgQW5pbWF0ZWRTaGVldCA9IHJlcXVpcmUoXCIuL2FuaW1hdGVkLXNoZWV0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBBbmltYXRlZFNoZWV0KCcjc3ZnLTInLCB7XG4gICAga2V5ZnJhbWVzOiBbe1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMjAwMCxcbiAgICAgICAgcmVtb3ZlOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc3ZnKSB7XG4gICAgICAgICAgICB2YXIgdyA9IDE5MjA7IC8vIHJlc29sdXRpb24gdGhlIHZpZXdib3ggc2NhbGluZyBpcyBiYXNlZCBvblxuICAgICAgICAgICAgdmFyIHBhdGggPSBbW3cgLyAyICsgODAwLCAtMTUwXSwgW3cgLyAyICsgODAwLCA2MDBdLCBbdyAvIDIgKyAxMDAsIDYwMF0sIFt3IC8gMiAtIDI4MCwgOTgwXSwgW3cgLyAyIC0gNTAwLCAxMjAwXSwgW3cgLyAyIC0gNTAwLCAyMTUwXV07XG4gICAgICAgICAgICB2YXIgYmV6aWVyTGluZSA9IGQzLmxpbmUoKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgICAgICB9KS55KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUnKS5kYXRhKFt3aW5kb3cucGFnZVlPZmZzZXRdKS5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBiZXppZXJMaW5lKHBhdGgpKS5hdHRyKCdzdHJva2UnLCAnI0ZGRkZGRicpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEwKS5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgLy8uYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKVxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cm9rZUxlbmd0aCA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJva2VMZW5ndGggKyAnICcgKyBzdHJva2VMZW5ndGg7XG4gICAgICAgICAgICB9KS5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb3RhbExlbmd0aCgpIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3ZnLCBjcmVhdGVTY29wZSwgaW50ZXJwb2xhdGVQZXJjZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9ICQoc3ZnLm5vZGUoKSkub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgICAgIHZhciBwb3NZID0gTWF0aC5tYXgoMCwgd2luZG93LnBhZ2VZT2Zmc2V0ICsgd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVTcGVlZCA9IDEuNTtcblxuICAgICAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ21lZGl1bScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVNwZWVkID0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50ID09PSAnc21hbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHBvc1kgKiBsaW5lU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudCB3aGVuIHBhdGggaGFzIHJlYWNoZWQgaXRzIGZ1bGwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBuZXcgRXZlbnQoJ3BhdGgyRW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZnJvbTogMTQ1MCxcbiAgICAgICAgdG86IDE1NTAsXG4gICAgICAgIHJlbW92ZTogZmFsc2UsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN2Zykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gc3ZnLnNlbGVjdCgnI2NoaXAnKS5hdHRyKCd6LWluZGV4JywgOTkpLm1vdmVUb0Zyb250KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3ZnLCBjcmVhdGVTY29wZSwgaW50ZXJwb2xhdGVQZXJjZW50KSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBkMy5pbnRlcnBvbGF0ZSgnZ3JheScsICd3aGl0ZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zdHlsZSgnZmlsbCcsIGNvbG9yKGludGVycG9sYXRlUGVyY2VudCkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogMjAwMCxcbiAgICAgICAgcmVtb3ZlOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc3ZnKSB7XG4gICAgICAgICAgICB2YXIgdyA9IDE5MjA7IC8vIHJlc29sdXRpb24gdGhlIHZpZXdib3ggc2NhbGluZyBpcyBiYXNlZCBvblxuICAgICAgICAgICAgdmFyIHBhdGggPSBbW3cgLyAyIC0gMjMwLCAxMDAwXSwgW3cgLyAyIC0gNDUwLCAxMjIwXSwgW3cgLyAyIC0gNDUwLCAyMTUwXV07XG4gICAgICAgICAgICB2YXIgYmV6aWVyTGluZSA9IGQzLmxpbmUoKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgICAgICB9KS55KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUnKS5kYXRhKFt3aW5kb3cucGFnZVlPZmZzZXRdKS5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBiZXppZXJMaW5lKHBhdGgpKS5hdHRyKCdzdHJva2UnLCAnI0ZGRkZGRicpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEwKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJva2VMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Ryb2tlTGVuZ3RoICsgJyAnICsgc3Ryb2tlTGVuZ3RoO1xuICAgICAgICAgICAgfSkuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN2ZywgY3JlYXRlU2NvcGUsIGludGVycG9sYXRlUGVyY2VudCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdmdZID0gJChzdmcubm9kZSgpKS5vZmZzZXQoKS50b3A7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZVNwZWVkID0gMS41O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFkgPSBzdmdZICsgOTAwO1xuICAgICAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ21lZGl1bScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVNwZWVkID0gMy45MDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gc3ZnWSArIDEwMDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50ID09PSAnc21hbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHN2Z1k7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBvc1kgPSBNYXRoLm1heCgwLCB3aW5kb3cucGFnZVlPZmZzZXQgLSBzdGFydFkpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHBvc1kgKiBsaW5lU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudCB3aGVuIHBhdGggaGFzIHJlYWNoZWQgaXRzIGZ1bGwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBuZXcgRXZlbnQoJ3BhdGgyRW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZnJvbTogMTU1MCxcbiAgICAgICAgdG86IDIwMDAsXG4gICAgICAgIHJlbW92ZTogZmFsc2UsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN2Zykge1xuICAgICAgICAgICAgdmFyIHcgPSAxOTIwOyAvLyByZXNvbHV0aW9uIHRoZSB2aWV3Ym94IHNjYWxpbmcgaXMgYmFzZWQgb25cbiAgICAgICAgICAgIHZhciBwYXRoID0gW1t3IC8gMiAtIDE2MCwgMTAwMF0sIFt3IC8gMiAtIDQwMCwgMTI1MF0sIFt3IC8gMiAtIDQwMCwgMjE1MF1dO1xuICAgICAgICAgICAgdmFyIGJlemllckxpbmUgPSBkMy5saW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICAgICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YShbd2luZG93LnBhZ2VZT2Zmc2V0XSkuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgYmV6aWVyTGluZShwYXRoKSkuYXR0cignc3Ryb2tlJywgJyNGRkZGRkYnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxMCkuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Ryb2tlTGVuZ3RoID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cm9rZUxlbmd0aCArICcgJyArIHN0cm9rZUxlbmd0aDtcbiAgICAgICAgICAgIH0pLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdmcsIGNyZWF0ZVNjb3BlLCBpbnRlcnBvbGF0ZVBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ZnWSA9ICQoc3ZnLm5vZGUoKSkub2Zmc2V0KCkudG9wO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVTcGVlZCA9IDEuNTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gc3ZnWSArIDkwMDtcbiAgICAgICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdtZWRpdW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDMuOTA7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHN2Z1kgKyAxMDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ3NtYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3BlZWQgPSA0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFkgPSBzdmdZIC0gNTA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBvc1kgPSBNYXRoLm1heCgwLCB3aW5kb3cucGFnZVlPZmZzZXQgLSBzdGFydFkpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHBvc1kgKiBsaW5lU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudCB3aGVuIHBhdGggaGFzIHJlYWNoZWQgaXRzIGZ1bGwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBuZXcgRXZlbnQoJ3BhdGgyRW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZnJvbTogMTU1MCxcbiAgICAgICAgdG86IDIwMDAsXG4gICAgICAgIHJlbW92ZTogZmFsc2UsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN2Zykge1xuICAgICAgICAgICAgdmFyIHcgPSAxOTIwOyAvLyByZXNvbHV0aW9uIHRoZSB2aWV3Ym94IHNjYWxpbmcgaXMgYmFzZWQgb25cbiAgICAgICAgICAgIHZhciBwYXRoID0gW1t3IC8gMiAtIDEyMCwgMTAzMF0sIFt3IC8gMiAtIDM1MCwgMTI3MF0sIFt3IC8gMiAtIDM1MCwgMjE1MF1dO1xuICAgICAgICAgICAgdmFyIGJlemllckxpbmUgPSBkMy5saW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICAgICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YShbd2luZG93LnBhZ2VZT2Zmc2V0XSkuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgYmV6aWVyTGluZShwYXRoKSkuYXR0cignc3Ryb2tlJywgJyNGRkZGRkYnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxMCkuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Ryb2tlTGVuZ3RoID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cm9rZUxlbmd0aCArICcgJyArIHN0cm9rZUxlbmd0aDtcbiAgICAgICAgICAgIH0pLmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdmcsIGNyZWF0ZVNjb3BlLCBpbnRlcnBvbGF0ZVBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ZnWSA9ICQoc3ZnLm5vZGUoKSkub2Zmc2V0KCkudG9wO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVTcGVlZCA9IDEuNTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gc3ZnWSArIDkwMDtcbiAgICAgICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdtZWRpdW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDMuOTA7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHN2Z1kgKyAxMDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ3NtYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3BlZWQgPSA0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFkgPSBzdmdZIC0gNTA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBvc1kgPSBNYXRoLm1heCgwLCB3aW5kb3cucGFnZVlPZmZzZXQgLSBzdGFydFkpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHBvc1kgKiBsaW5lU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudCB3aGVuIHBhdGggaGFzIHJlYWNoZWQgaXRzIGZ1bGwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBuZXcgRXZlbnQoJ3BhdGgyRW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1dXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2FuaW1hdGlvbi0yLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlyZCBhbmltYXRpb25cbnZhciBBbmltYXRlZFNoZWV0ID0gcmVxdWlyZShcIi4vYW5pbWF0ZWQtc2hlZXRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEFuaW1hdGVkU2hlZXQoJyNzdmctMycsIHtcbiAgICBkZWZzOiBbXG4gICAgLy8gVE9ETzogaXMgYSBmaWx0ZXIgaW5kZXBlbmRlbnRseSB1c2FibGUgZm9yIG11bHRpcGxlIGVsZW1lbnRzP1xuICAgIHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoc3ZnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ZnLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwiZmlsdGVyXCIpLmF0dHIoXCJpZFwiLCBcIm1vdGlvbkZpbHRlcjFcIikuYXBwZW5kKFwiZmVHYXVzc2lhbkJsdXJcIikuYXR0cihcImNsYXNzXCIsIFwiYmx1clZhbHVlczFcIikuYXR0cihcImluXCIsIFwiU291cmNlR3JhcGhpY1wiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIFwiMTAgMTBcIik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHN2Zykge1xuICAgICAgICAgICAgcmV0dXJuIHN2Zy5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImZpbHRlclwiKS5hdHRyKFwiaWRcIiwgXCJtb3Rpb25GaWx0ZXIyXCIpLmFwcGVuZChcImZlR2F1c3NpYW5CbHVyXCIpLmF0dHIoXCJjbGFzc1wiLCBcImJsdXJWYWx1ZXMyXCIpLmF0dHIoXCJpblwiLCBcIlNvdXJjZUdyYXBoaWNcIikuYXR0cihcInN0ZERldmlhdGlvblwiLCBcIjEwIDEwXCIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihzdmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdmcuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJmaWx0ZXJcIikuYXR0cihcImlkXCIsIFwibW90aW9uRmlsdGVyM1wiKS5hcHBlbmQoXCJmZUdhdXNzaWFuQmx1clwiKS5hdHRyKFwiY2xhc3NcIiwgXCJibHVyVmFsdWVzM1wiKS5hdHRyKFwiaW5cIiwgXCJTb3VyY2VHcmFwaGljXCIpLmF0dHIoXCJzdGREZXZpYXRpb25cIiwgXCIxMCAxMFwiKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoc3ZnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ZnLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwiZmlsdGVyXCIpLmF0dHIoXCJpZFwiLCBcIm1vdGlvbkZpbHRlcjRcIikuYXBwZW5kKFwiZmVHYXVzc2lhbkJsdXJcIikuYXR0cihcImNsYXNzXCIsIFwiYmx1clZhbHVlczRcIikuYXR0cihcImluXCIsIFwiU291cmNlR3JhcGhpY1wiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIFwiMTAgMTBcIik7XG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBrZXlmcmFtZXM6IFt7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAyMDAwLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHZhciB3ID0gMTkyMDsgLy8gcmVzb2x1dGlvbiB0aGUgdmlld2JveCBzY2FsaW5nIGlzIGJhc2VkIG9uXG4gICAgICAgICAgICB2YXIgaCA9IDEwODA7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtbdyAvIDIgLSA1MDAsIC0xNTBdLCBbdyAvIDIgLSA1MDAsIDE1MF0sIFt3IC8gMiAtIDgxMCwgMTUwXSwgW3cgLyAyIC0gODEwLCA0ODBdLCBbdyAvIDIgLSA1ODAsIDQ4MF0sIFt3IC8gMiAtIDU4MCwgMjAwMF1dO1xuICAgICAgICAgICAgdmFyIGJlemllckxpbmUgPSBkMy5saW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICAgICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YShbd2luZG93LnBhZ2VZT2Zmc2V0XSkuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgYmV6aWVyTGluZShwYXRoKSkuYXR0cignc3Ryb2tlJywgJyNGRkZGRkYnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxMCkuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKS5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJva2VMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Ryb2tlTGVuZ3RoICsgJyAnICsgc3Ryb2tlTGVuZ3RoO1xuICAgICAgICAgICAgfSkuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN2ZywgY3JlYXRlU2NvcGUsIGludGVycG9sYXRlUGVyY2VudCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFkgPSAkKHN2Zy5ub2RlKCkpLm9mZnNldCgpLnRvcCAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDM7XG4gICAgICAgICAgICAgICAgdmFyIHBvc1kgPSBNYXRoLm1heCgwLCB3aW5kb3cucGFnZVlPZmZzZXQgLSBzdGFydFkpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lU3BlZWQgPSAxLjY7XG5cbiAgICAgICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdtZWRpdW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ3NtYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3BlZWQgPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSBwb3NZICogbGluZVNwZWVkO1xuXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgd2hlbiBwYXRoIGhhcyByZWFjaGVkIGl0cyBmdWxsIGxlbmd0aFxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEV2ZW50ID0gbmV3IEV2ZW50KCdwYXRoMkVuZCcpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAyMDAwLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHZhciB3ID0gMTkyMDsgLy8gcmVzb2x1dGlvbiB0aGUgdmlld2JveCBzY2FsaW5nIGlzIGJhc2VkIG9uXG4gICAgICAgICAgICB2YXIgaCA9IDEwODA7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtbdyAvIDIgLSA0NTAsIC0xNTBdLCBbdyAvIDIgLSA0NTAsIDIwXSwgW3cgLyAyIC0gMjQwLCAyMF0sIFt3IC8gMiAtIDI0MCwgOTUwXSwgW3cgLyAyIC0gNTIwLCA5NTBdLCBbdyAvIDIgLSA1MjAsIDEyODBdLCBbdyAvIDIgLSA3MCwgMTI4MF0sIFt3IC8gMiAtIDYyMCwgMjAwMF1dO1xuICAgICAgICAgICAgdmFyIGJlemllckxpbmUgPSBkMy5saW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICAgICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YShbd2luZG93LnBhZ2VZT2Zmc2V0XSkuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgYmV6aWVyTGluZShwYXRoKSkuYXR0cignc3Ryb2tlJywgJyNGRkZGRkYnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxMCkuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKS5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJva2VMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Ryb2tlTGVuZ3RoICsgJyAnICsgc3Ryb2tlTGVuZ3RoO1xuICAgICAgICAgICAgfSkuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN2ZywgY3JlYXRlU2NvcGUsIGludGVycG9sYXRlUGVyY2VudCkge1xuICAgICAgICAgICAgLy9yZXR1cm47XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9ICQoc3ZnLm5vZGUoKSkub2Zmc2V0KCkudG9wIC0gd2luZG93LmlubmVySGVpZ2h0IC8gMztcbiAgICAgICAgICAgICAgICB2YXIgcG9zWSA9IE1hdGgubWF4KDAsIHdpbmRvdy5wYWdlWU9mZnNldCAtIHN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVTcGVlZCA9IDEuOTU7XG5cbiAgICAgICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdtZWRpdW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ3NtYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3BlZWQgPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSBwb3NZICogbGluZVNwZWVkO1xuXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgd2hlbiBwYXRoIGhhcyByZWFjaGVkIGl0cyBmdWxsIGxlbmd0aFxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEV2ZW50ID0gbmV3IEV2ZW50KCdwYXRoMkVuZCcpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAyMDAwLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHZhciB3ID0gMTkyMDsgLy8gcmVzb2x1dGlvbiB0aGUgdmlld2JveCBzY2FsaW5nIGlzIGJhc2VkIG9uXG4gICAgICAgICAgICB2YXIgaCA9IDEwODA7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtbdyAvIDIgLSA0MDAsIC0xNTBdLCBbdyAvIDIgLSA0MDAsIC04MF0sIFt3IC8gMiAtIDQwMCwgLTMwXSwgW3cgLyAyIC0gMjAwLCAtMzBdLCBbdyAvIDIgKyAxNTAsIC0zMF0sIFt3IC8gMiArIDE1MCwgMTM1MF0sIFt3IC8gMiArIDQ5MCwgMTM1MF0sIFt3IC8gMiArIDQ5MCwgMTY4MF0sIFt3IC8gMiArIDQwLCAxNjgwXSwgW3cgLyAyIC0gNzUwLCAyMDAwXV07XG4gICAgICAgICAgICB2YXIgYmV6aWVyTGluZSA9IGQzLmxpbmUoKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgICAgICB9KS55KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUnKS5kYXRhKFt3aW5kb3cucGFnZVlPZmZzZXRdKS5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCBiZXppZXJMaW5lKHBhdGgpKS5hdHRyKCdzdHJva2UnLCAnI0ZGRkZGRicpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEwKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cm9rZUxlbmd0aCA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gdGhpcy5nZXRUb3RhbExlbmd0aCgpIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJva2VMZW5ndGggKyAnICcgKyBzdHJva2VMZW5ndGg7XG4gICAgICAgICAgICB9KS5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb3RhbExlbmd0aCgpIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3ZnLCBjcmVhdGVTY29wZSwgaW50ZXJwb2xhdGVQZXJjZW50KSB7XG4gICAgICAgICAgICAvL3JldHVybjtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdzdHJva2UtZGFzaG9mZnNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gJChzdmcubm9kZSgpKS5vZmZzZXQoKS50b3AgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAzO1xuICAgICAgICAgICAgICAgIHZhciBwb3NZID0gTWF0aC5tYXgoMCwgd2luZG93LnBhZ2VZT2Zmc2V0IC0gc3RhcnRZKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVNwZWVkID0gMi4zMTtcblxuICAgICAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ21lZGl1bScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVNwZWVkID0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50ID09PSAnc21hbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHBvc1kgKiBsaW5lU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBldmVudCB3aGVuIHBhdGggaGFzIHJlYWNoZWQgaXRzIGZ1bGwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBuZXcgRXZlbnQoJ3BhdGgyRW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IDIwMDAsXG4gICAgICAgIHJlbW92ZTogZmFsc2UsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHN2Zykge1xuICAgICAgICAgICAgdmFyIHcgPSAxOTIwOyAvLyByZXNvbHV0aW9uIHRoZSB2aWV3Ym94IHNjYWxpbmcgaXMgYmFzZWQgb25cbiAgICAgICAgICAgIHZhciBoID0gMTA4MDtcbiAgICAgICAgICAgIHZhciBwYXRoID0gW1t3IC8gMiAtIDM1MCwgLTE1MF0sIFt3IC8gMiAtIDM1MCwgLTgwXSwgW3cgLyAyICsgMjAwLCAtODBdLCBbdyAvIDIgKyAyMDAsIDU1MF0sIFt3IC8gMiArIDY5MCwgNTUwXSwgW3cgLyAyICsgNjkwLCAxNzMwXSwgW3cgLyAyIC0gMTEyMCwgMjAwMF1dO1xuICAgICAgICAgICAgdmFyIGJlemllckxpbmUgPSBkMy5saW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICAgICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBzdmcuc2VsZWN0QWxsKCdsaW5lJykuZGF0YShbd2luZG93LnBhZ2VZT2Zmc2V0XSkuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgYmV6aWVyTGluZShwYXRoKSkuYXR0cignc3Ryb2tlJywgJyNGRkZGRkYnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxMCkuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKS5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJva2VMZW5ndGggPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Ryb2tlTGVuZ3RoICsgJyAnICsgc3Ryb2tlTGVuZ3RoO1xuICAgICAgICAgICAgfSkuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG90YWxMZW5ndGgoKSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN2ZywgY3JlYXRlU2NvcGUsIGludGVycG9sYXRlUGVyY2VudCkge1xuICAgICAgICAgICAgLy9yZXR1cm47XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cignc3Ryb2tlLWRhc2hvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9ICQoc3ZnLm5vZGUoKSkub2Zmc2V0KCkudG9wIC0gd2luZG93LmlubmVySGVpZ2h0IC8gMztcbiAgICAgICAgICAgICAgICB2YXIgcG9zWSA9IE1hdGgubWF4KDAsIHdpbmRvdy5wYWdlWU9mZnNldCAtIHN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVTcGVlZCA9IDIuNDY7XG5cbiAgICAgICAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmN1cnJlbnQgPT09ICdtZWRpdW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGVlZCA9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCA9PT0gJ3NtYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3BlZWQgPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLmdldFRvdGFsTGVuZ3RoKCkgLSBwb3NZICogbGluZVNwZWVkO1xuXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgd2hlbiBwYXRoIGhhcyByZWFjaGVkIGl0cyBmdWxsIGxlbmd0aFxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEV2ZW50ID0gbmV3IEV2ZW50KCdwYXRoMkVuZCcpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDc1MCxcbiAgICAgICAgdG86IDk1MCxcbiAgICAgICAgcmVtb3ZlOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc3ZnKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBzdmcuc2VsZWN0QWxsKCcjcGF0aC1pbWFnZS0xJykuYXR0cihcImZpbHRlclwiLCBcInVybCgjbW90aW9uRmlsdGVyMSlcIikuYXR0cihcIm9wYWNpdHlcIiwgMCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3ZnLCBjcmVhdGVTY29wZSwgaW50ZXJwb2xhdGVQZXJjZW50KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkludGVycG9sYXRvciA9IGQzLmludGVycG9sYXRlTnVtYmVyKDQwMCwgMjAwKTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5SW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoMCwgMSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndmlzaWJpbGl0eScsICd2aXNpYmxlJykuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSArIFwiLCAyMDApXCIpLmF0dHIoXCJvcGFjaXR5XCIsIG9wYWNpdHlJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG5cbiAgICAgICAgICAgIHZhciBibHVySW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVTdHJpbmcoXCIxMCAxMFwiLCBcIjAgMFwiKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb3Rpb25GaWx0ZXIxIC5ibHVyVmFsdWVzMVwiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIGJsdXJJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDEwNTAsXG4gICAgICAgIHRvOiAxMjUwLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3RBbGwoJyNwYXRoLWltYWdlLTInKS5hdHRyKFwiZmlsdGVyXCIsIFwidXJsKCNtb3Rpb25GaWx0ZXIyKVwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdmcsIGNyZWF0ZVNjb3BlLCBpbnRlcnBvbGF0ZVBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoMTAwMCwgMTIwMCk7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eUludGVycG9sYXRvciA9IGQzLmludGVycG9sYXRlTnVtYmVyKDAsIDEpO1xuICAgICAgICAgICAgdmFyIGJsdXJJbnRlcnBvbGF0b3IgPSBkMy5pbnRlcnBvbGF0ZVN0cmluZyhcIjEwIDEwXCIsIFwiMCAwXCIpO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndmlzaWJpbGl0eScsICd2aXNpYmxlJykuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSArIFwiLCA2MDApXCIpLmF0dHIoXCJvcGFjaXR5XCIsIG9wYWNpdHlJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb3Rpb25GaWx0ZXIyIC5ibHVyVmFsdWVzMlwiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIGJsdXJJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDExNTAsXG4gICAgICAgIHRvOiAxMzUwLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3RBbGwoJyNwYXRoLWltYWdlLTMnKS5hdHRyKFwiZmlsdGVyXCIsIFwidXJsKCNtb3Rpb25GaWx0ZXIzKVwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdmcsIGNyZWF0ZVNjb3BlLCBpbnRlcnBvbGF0ZVBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoNzAwLCA1MDApO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHlJbnRlcnBvbGF0b3IgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcigwLCAxKTtcbiAgICAgICAgICAgIHZhciBibHVySW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVTdHJpbmcoXCIxMCAxMFwiLCBcIjAgMFwiKTtcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yKGludGVycG9sYXRlUGVyY2VudCkgKyBcIiwgMTAwMClcIikuYXR0cihcIm9wYWNpdHlcIiwgb3BhY2l0eUludGVycG9sYXRvcihpbnRlcnBvbGF0ZVBlcmNlbnQpKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb3Rpb25GaWx0ZXIzIC5ibHVyVmFsdWVzM1wiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIGJsdXJJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGZyb206IDEzNTAsXG4gICAgICAgIHRvOiAxNTUwLFxuICAgICAgICByZW1vdmU6IGZhbHNlLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzdmcpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHN2Zy5zZWxlY3RBbGwoJyNwYXRoLWltYWdlLTQnKS5hdHRyKFwiZmlsdGVyXCIsIFwidXJsKCNtb3Rpb25GaWx0ZXI0KVwiKS5hdHRyKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdmcsIGNyZWF0ZVNjb3BlLCBpbnRlcnBvbGF0ZVBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoODAwLCAxMDAwKTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5SW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoMCwgMSk7XG4gICAgICAgICAgICB2YXIgYmx1ckludGVycG9sYXRvciA9IGQzLmludGVycG9sYXRlU3RyaW5nKFwiMTAgMTBcIiwgXCIwIDBcIik7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgdHJhbnNpdGlvbkludGVycG9sYXRvcihpbnRlcnBvbGF0ZVBlcmNlbnQpICsgXCIsIDE0MDApXCIpLmF0dHIoXCJvcGFjaXR5XCIsIG9wYWNpdHlJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb3Rpb25GaWx0ZXI0IC5ibHVyVmFsdWVzNFwiKS5hdHRyKFwic3RkRGV2aWF0aW9uXCIsIGJsdXJJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVQZXJjZW50KSk7XG4gICAgICAgIH1cbiAgICB9XVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9hbmltYXRpb24tMy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9